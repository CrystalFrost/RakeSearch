Общий алгоритм Rake-поиска диагональных латинских квадратов:

1. Вспомогательные функции:
GetFirstFile	- возвращает имя первого файла по указанной маске
PingStorage	- проверяет доступность указанного файла
Compute		- верхний цикл программы в рамках которого она программа копирует себе
		  workunit, запускает расчёт, а после его завершения - отправляет result.
		  При запуске проверяется - есть ли файл контрольной точки и если он есть,
		  то расчёты запускаются с него.

2. Основные классы:
Square		- Класс "Латинский квадрат". Реализует хранение матрицы,
		  операторы сравнения, сериализацию в текстовый файл и из него,
		  Есть функции проверки диагональности квадрата и того, что он латинский.
		  Плюс статическая функция посчёта степени ортогональности.

Generator	- Класс "Генератор латинских квадратов"
		  После проведения инициализации, генератор запускается методом Start().
		  При генерации очередного квадрата формируется событие, на которое можно
		  подписаться и обрабатывать сгенерированный квадрат.
		  Реализован функционал сериализации состояния генератора в текстовый файл
		  и обратно.

PairSearch	- Наследник класса Generator, осуществляющий также генерацию ДЛК,
		  но таких, которые были бы ортогональны ранее сгенерированному ДЛК
		  в базовом классе. После инициализации поиск запускается методом 
		  StartPairSearch который, в свою очередь запускает встроенный 
		  в него в виде отдельнольного объекта генератор квадрата A, 
		  предварительно подписавшись на событие генерации ДЛК.
		  В Rake-поиске этот класс не используется.

MovePairSearch	- Класс непосредственно "грабления" квадратов.
		  Запускает генерацию квадратов генератором, встроенным в него 
		  как член класса, предварительно подписавшись на событие.
		  При генерации очередного квадрата, выполняет перестановки его строк,
		  проверяя, не получился ли квадрат, ортогональный квадрату из генератора.


3. Общий алгоритм генерации ДЛК:
3.1. Из файла параметров считывается путь обхода клеток квадрата.
     Заполнение квадрата - это достижение конца пути. Генерация происходит 
     прямо в функции Start, в цикле do {...} while, в котором происходит перемещение
     по заданному пути изменением переменной cellId.
3.2. Когда мы приходим в очередную клетку квадрата, то программа в for-цикле ищет, 
     какие ещё значения можно записать в клетку, используя для этого вспомогательные 
     массивы с флагами:
         - primary[i] = 0 | 1. Если primary[i] == 0, то i на главной диагонали ещё не встречается.
         - secondary[i] = 0 | 1. Аналогично primary, только для побочной диагонали.
         - columns[i][columnId] = 0 | 1. Тоже самое для значения i в столбце columndId
         - rows[rowId][i] = 0 | 1. Тоже самое для значения i в строке rowId
         - cellsHistory[rowId][columnId][i] = 0 | 1. Использовалось ли значение i в клетке 
           с адресом [rowId][columnId].
3.3. При нахождении подходящего значения оно записывается в клетку квадрата с проставлением 
     соответствующих значений в массивах флагов. Если при этом, в клетке уже было какое-то значение,
     то оно "вычёркивается" из всех массивов флагов кроме массива cellsHistory.
     Если подходящего значения найти не удаётся, то делается шаг назад (cellId--), значение 
     отмечается в массивах флагов как использованное, а история соответствующей клетки - полностью 
     зачищается.
3.4. Если добрались до конца пути (cellId == cellsInPath - 1) то вызываем функцию обработки 
     найденного квадрата. В ней - генерируем событие.
3.5. Расчёт завершается при достижении значения keyValue в клетке [keyRowId][keyColumnId],
     считываемых из файла параметров, либо, если keyValue == -1, то когда мы полностью обошли 
     все клетки и вернулись обратно, выйдя за пределы набора клеток (cellId < 0).
